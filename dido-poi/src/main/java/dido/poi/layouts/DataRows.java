package dido.poi.layouts;

import dido.data.DataSchema;
import dido.data.DidoData;
import dido.data.ReadSchema;
import dido.how.DataIn;
import dido.how.DataInHow;
import dido.how.DataOut;
import dido.how.DataOutHow;
import dido.how.conversion.DefaultConversionProvider;
import dido.how.conversion.DidoConversionProvider;
import dido.poi.*;
import dido.poi.data.DataCell;
import dido.poi.data.PoiRowsOut;
import dido.poi.style.CompositeStyleFactory;
import dido.poi.style.DefaultStyleProivderFactory;
import dido.poi.style.StyleBean;
import dido.poi.style.StyleFactoryRegistry;
import dido.poi.utils.SchemaAndCells;
import org.apache.poi.ss.usermodel.Sheet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.*;

/**
 * @author rob
 * @oddjob.description Define an area in a spreadsheet sheet for reading
 * and writing rows to.
 */
public class DataRows implements DataInHow<BookInProvider>, DataOutHow<BookOutProvider> {

    private static final Logger logger = LoggerFactory.getLogger(DataRows.class);

    /**
     * @oddjob.property
     * @oddjob.description The starting row in the sheet.
     * @oddjob.required No. Defaults to 1.
     */
    private int firstRow = 1;

    /**
     * @oddjob.property
     * @oddjob.description The starting column in the sheet.
     * @oddjob.required No. Defaults to 1.
     */
    private int firstColumn = 1;

    /**
     * @oddjob.property
     * @oddjob.description The last row in the sheet written to by this
     * layout.
     * @oddjob.required Read Only.
     */
    private int lastRow;

    /**
     * @oddjob.property
     * @oddjob.description Should a header row be written (true/false).
     * @oddjob.required No. Defaults to false.
     */
    private boolean withHeader;

    /**
     * @oddjob.property
     * @oddjob.description The style name used in the header row.
     * @oddjob.required No. A default header style will be used.
     */
    private String headingsStyle;

    /**
     * @oddjob.property
     * @oddjob.description If true then automatically set the width of the column to the
     * widest column value when values have finished being written.
     * @oddjob.required No. Defaults to false.
     */
    private boolean autoWidth;

    /**
     * @oddjob.property
     * @oddjob.description If true then automatically set an auto filter on
     * the column.
     * @oddjob.required No. Defaults to false.
     */
    private boolean autoFilter;

    /**
     * @oddjob.property
     * @oddjob.description Set when reading if there is a header row to
     * read headings from. Used to derive a binding type if one is required
     * and there an no child layouts to derive it from.
     * @oddjob.required No. Read only.
     */
    private String[] headings;

    /**
     * @oddjob.property
     * @oddjob.description The name of the sheet to read or write. When
     * reading if a name is given and the sheet doesn't exist in the
     * workbook then no data will be read.
     * @oddjob.required No. If not supplied the next sheet is used.
     */
    private String sheetName;

    /**
     * @oddjob.property
     * @oddjob.description Allow a number of named styles to be set for
     * the book. See {@link StyleBean}.
     * @oddjob.required No.
     */
    private final StyleFactoryRegistry styles = new StyleFactoryRegistry();

    private final List<DataCell> of = new LinkedList<>();

    /**
     * @oddjob.property
     * @oddjob.description Provides conversions.
     * @oddjob.required Set by Oddjob.
     */
    private DidoConversionProvider conversionProvider;

    private DataSchema schema;

    @Override
    public Class<BookInProvider> getInType() {
        return BookInProvider.class;
    }

    @Override
    public Class<BookOutProvider> getOutType() {
        return BookOutProvider.class;
    }

    /**
     * @param index 0 based index.
     * @param child The child, null will remove the child for the given index.
     * @oddjob.property of
     * @oddjob.description The child layouts for the rows. These define
     * the columns created. Typically they will be one of {@link TextCell},
     * {@link NumericCell}, {@link DateCell}, {@link BooleanCell},
     * or {@link NumericFormulaCell}.
     * @oddjob.required No, they can be generated by a binding.
     */
    public void setOf(int index, DataCell child) {

        if (child == null) {
            of.remove(index);
        } else {
            of.add(index, child);
        }
    }

    public DidoConversionProvider getConversionProvider() {
        return conversionProvider;
    }

    @Inject
    public void setConversionProvider(DidoConversionProvider conversionProvider) {
        this.conversionProvider = conversionProvider;
    }

    @Override
    public DataIn inFrom(BookInProvider bookInProvider) {

        return DataInPoi.with()
                .sheetName(this.sheetName)
                .firstRow(this.firstRow)
                .firstColumn(this.firstColumn)
                .schema(this.schema)
                .cells(this.of)
                .schemaListener(schema -> this.headings = schema.getFieldNames().toArray(new String[0]))
                .header(this.withHeader)
                .converter(this.conversionProvider)
                .make()
                .inFrom(bookInProvider);

    }

    class MainWriter implements DataOut {

        private final RowsOut rowsOut;

        private final Collection<CellOut> cellOuts;

        private final Runnable closeHandler;

        public MainWriter(RowsOut rowsOut,
                          Collection<CellOut> cellOuts,
                          Runnable closeHandler) {
            this.rowsOut = rowsOut;
            this.cellOuts = cellOuts;
            this.closeHandler = closeHandler;
        }

        @Override
        public void accept(DidoData data) {

            rowsOut.nextRow();

            logger.trace("[{}] writing row {}", DataRows.this, rowsOut.getLastRow());

            for (CellOut dataCell : cellOuts) {
                writeCell(dataCell, data);
            }

            lastRow = rowsOut.getLastRow();
        }

        <T> void writeCell(CellOut cellOut, DidoData data) {

            RowOut rowOut = rowsOut.getRowOut();

            cellOut.setValue(rowOut, data);
        }

        @Override
        public void close() {

            if (autoFilter) {
                rowsOut.autoFilter();
            }

            if (autoWidth) {
                rowsOut.autoWidth();
            }

            closeHandler.run();

            logger.debug("[{}] closed writer at row [{}]", DataRows.this, lastRow);
        }
    }

    @Override
    public DataOut outTo(BookOutProvider outTo) {

        BookOut bookOut = outTo.provideBookOut();

        Sheet sheet = bookOut.getOrCreateSheet(this.sheetName);

        PoiRowsOut rowsOut = new PoiRowsOut(sheet,
                bookOut.createStyles(new CompositeStyleFactory(new DefaultStyleProivderFactory(), styles)),
                firstRow,
                firstColumn);

        logger.debug("Creating writer for [{}]", rowsOut);

        WriterFactory writerFactory = new WriterFactory(rowsOut, bookOut::close);

        if (this.schema == null) {
            if (this.of.isEmpty()) {
                return new UnknownWriter(writerFactory,
                        SchemaAndCells.withCellFactory(new DataCellFactory()));
            } else {
                return new UnknownWriter(writerFactory,
                        SchemaAndCells.withCells(this.of));
            }
        } else {
            if (this.of.isEmpty()) {
                return writerFactory.create(SchemaAndCells.withCellFactory(
                        new DataCellFactory()).fromSchema(this.schema));
            } else {
                return writerFactory.create(SchemaAndCells.withCells(
                        this.of).fromSchema(this.schema));
            }
        }
    }

    class UnknownWriter implements DataOut {

        private final WriterFactory writerFactory;

        private final SchemaAndCells.Factory<DataCell> cellFactory;

        private DataOut delegate;

        UnknownWriter(WriterFactory writerFactory,
                      SchemaAndCells.Factory<DataCell> cellFactory) {
            this.writerFactory = writerFactory;
            this.cellFactory = cellFactory;
        }

        @Override
        public void accept(DidoData data) {

            if (delegate == null) {
                SchemaAndCells<DataCell> schemaAndCells = cellFactory.fromSchema(data.getSchema());
                delegate = writerFactory.create(schemaAndCells);
            }
            delegate.accept(data);
        }

        @Override
        public void close() {
            if (delegate == null)  {
                delegate = writerFactory.create(cellFactory.noData());
            }

            delegate.close();
        }
    }

    class WriterFactory {

        private final RowsOut rowsOut;
        private final Runnable closeHandler;

        WriterFactory(RowsOut rowsOut, Runnable closeHandler) {
            this.rowsOut = rowsOut;
            this.closeHandler = closeHandler;
        }

        DataOut create(SchemaAndCells<? extends CellOutProvider> schemaAndCells) {

            DidoConversionProvider conversionProvider = Objects.requireNonNullElseGet(
                    DataRows.this.conversionProvider, DefaultConversionProvider::defaultInstance);

            ReadSchema schema = ReadSchema.from(schemaAndCells.getSchema());
            List<CellOut> cellOuts = new ArrayList<>(schemaAndCells.getDataCells().size());
            int lastIndex = 0;
            for (CellOutProvider cellProvider : schemaAndCells.getDataCells()) {

                if (cellProvider.getIndex() == 0) {
                    ++lastIndex;
                } else {
                    lastIndex = cellProvider.getIndex();
                }


                cellOuts.add(cellProvider.provideCellOut(
                        schema,
                        lastIndex,
                        conversionProvider));
            }

            if (withHeader) {
                HeaderRowOut headerRowOut = rowsOut.headerRow(headingsStyle);

                cellOuts.forEach(cs -> cs.writeHeader(headerRowOut));
            }

            logger.debug("[{}] initialised at [{}, {}]", this, firstRow, firstColumn);

            return new MainWriter(rowsOut, cellOuts, closeHandler);
        }
    }


    public boolean isWithHeader() {
        return withHeader;
    }

    public void setWithHeader(boolean withHeading) {
        this.withHeader = withHeading;
    }

    public boolean isAutoWidth() {
        return autoWidth;
    }

    public void setAutoWidth(boolean autoWidth) {
        this.autoWidth = autoWidth;
    }

    public String getHeadingsStyle() {
        return headingsStyle;
    }

    public void setHeadingsStyle(String headingsStyle) {
        this.headingsStyle = headingsStyle;
    }

    public int getFirstRow() {
        return firstRow;
    }

    public void setFirstRow(int startRow) {
        this.firstRow = startRow;
    }

    public int getFirstColumn() {
        return firstColumn;
    }

    public void setFirstColumn(int startColumn) {
        this.firstColumn = startColumn;
    }

    public boolean isAutoFilter() {
        return autoFilter;
    }

    public void setAutoFilter(boolean autoFilter) {
        this.autoFilter = autoFilter;
    }

    public int getLastRow() {
        return lastRow;
    }

    public String[] getHeadings() {
        return headings;
    }

    /**
     * Getter for sheet name.
     *
     * @return The sheet name.
     */
    public String getSheetName() {
        return sheetName;
    }

    /**
     * Setter for sheet name.
     *
     * @param sheetName The sheet name.
     */
    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }

    /**
     * Setter for mapped styles.
     *
     * @param styleName The name of the styles.
     * @param styleBean The style bean. If null then the style of the
     *                  given name will be removed.
     */
    public void setStyles(String styleName, StyleBean styleBean) {
        if (styleBean == null) {
            styles.removeStyle(styleName);
        } else {
            styles.registerStyle(styleName, styleBean);
        }
    }

    public DataSchema getSchema() {
        return schema;
    }

    public void setSchema(DataSchema schema) {
        this.schema = schema;
    }

    @Override
    public String toString() {
        String name = sheetName;
        return getClass().getSimpleName() +
                (name == null ? "" : " " + name);
    }
}
