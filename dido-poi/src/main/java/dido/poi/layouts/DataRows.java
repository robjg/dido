package dido.poi.layouts;

import dido.data.DataSchema;
import dido.how.DataIn;
import dido.how.DataInHow;
import dido.how.DataOut;
import dido.how.DataOutHow;
import dido.how.conversion.DidoConversionProvider;
import dido.poi.BookInProvider;
import dido.poi.BookOutProvider;
import dido.poi.DataInPoi;
import dido.poi.DataOutPoi;
import dido.poi.data.DataCell;
import dido.poi.style.StyleBean;
import dido.poi.style.StyleFactoryRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.LinkedList;
import java.util.List;

/**
 * @author rob
 * @oddjob.description Define an area in a spreadsheet sheet for reading
 * and writing rows to.
 */
public class DataRows implements DataInHow<BookInProvider>, DataOutHow<BookOutProvider> {

    private static final Logger logger = LoggerFactory.getLogger(DataRows.class);

    /**
     * @oddjob.property
     * @oddjob.description The starting row in the sheet.
     * @oddjob.required No. Defaults to 1.
     */
    private int firstRow = 1;

    /**
     * @oddjob.property
     * @oddjob.description The starting column in the sheet.
     * @oddjob.required No. Defaults to 1.
     */
    private int firstColumn = 1;

    /**
     * @oddjob.property
     * @oddjob.description The last row in the sheet written to by this
     * layout.
     * @oddjob.required Read Only.
     */
    private int lastRow;

    /**
     * @oddjob.property
     * @oddjob.description Should a header row be written (true/false).
     * @oddjob.required No. Defaults to false.
     */
    private boolean withHeader;

    /**
     * @oddjob.property
     * @oddjob.description The style name used in the header row.
     * @oddjob.required No. A default header style will be used.
     */
    private String headingsStyle;

    /**
     * @oddjob.property
     * @oddjob.description If true then automatically set the width of the column to the
     * widest column value when values have finished being written.
     * @oddjob.required No. Defaults to false.
     */
    private boolean autoWidth;

    /**
     * @oddjob.property
     * @oddjob.description If true then automatically set an auto filter on
     * the column.
     * @oddjob.required No. Defaults to false.
     */
    private boolean autoFilter;

    /**
     * @oddjob.property
     * @oddjob.description Set when reading if there is a header row to
     * read headings from. Used to derive a binding type if one is required
     * and there an no child layouts to derive it from.
     * @oddjob.required No. Read only.
     */
    private String[] headings;

    /**
     * @oddjob.property
     * @oddjob.description The name of the sheet to read or write. When
     * reading if a name is given and the sheet doesn't exist in the
     * workbook then no data will be read.
     * @oddjob.required No. If not supplied the next sheet is used.
     */
    private String sheetName;

    /**
     * @oddjob.property
     * @oddjob.description Allow a number of named styles to be set for
     * the book. See {@link StyleBean}.
     * @oddjob.required No.
     */
    private final StyleFactoryRegistry styles = new StyleFactoryRegistry();

    private final List<DataCell> of = new LinkedList<>();

    /**
     * @oddjob.property
     * @oddjob.description Provides conversions.
     * @oddjob.required Set by Oddjob.
     */
    private DidoConversionProvider conversionProvider;

    private DataSchema schema;

    @Override
    public Class<BookInProvider> getInType() {
        return BookInProvider.class;
    }

    @Override
    public Class<BookOutProvider> getOutType() {
        return BookOutProvider.class;
    }

    /**
     * @param index 0 based index.
     * @param child The child, null will remove the child for the given index.
     * @oddjob.property of
     * @oddjob.description The child layouts for the rows. These define
     * the columns created. Typically they will be one of {@link TextCell},
     * {@link NumericCell}, {@link DateCell}, {@link BooleanCell},
     * or {@link NumericFormulaCell}.
     * @oddjob.required No, they can be generated by a binding.
     */
    public void setOf(int index, DataCell child) {

        if (child == null) {
            of.remove(index);
        } else {
            of.add(index, child);
        }
    }

    public DidoConversionProvider getConversionProvider() {
        return conversionProvider;
    }

    @Inject
    public void setConversionProvider(DidoConversionProvider conversionProvider) {
        this.conversionProvider = conversionProvider;
    }

    @Override
    public DataIn inFrom(BookInProvider bookInProvider) {

        return DataInPoi.with()
                .sheetName(this.sheetName)
                .firstRow(this.firstRow)
                .firstColumn(this.firstColumn)
                .schema(this.schema)
                .columns(this.of)
                .schemaListener(schema -> this.headings = schema.getFieldNames().toArray(new String[0]))
                .header(this.withHeader)
                .conversionProvider(this.conversionProvider)
                .make()
                .inFrom(bookInProvider);

    }

    @Override
    public DataOut outTo(BookOutProvider outTo) {

        return DataOutPoi.with()
                .sheetName(this.sheetName)
                .firstRow(this.firstRow)
                .firstColumn(this.firstColumn)
                .schema(this.schema)
                .columns(this.of)
                .header(this.withHeader)
                .headerStyle(this.headingsStyle)
                .autoFilter(this.autoFilter)
                .autoWidth(this.autoWidth)
                .styles(this.styles)
                .conversionProvider(this.conversionProvider)
                .lastRow(rowNum -> lastRow = rowNum)
                .make()
                .outTo(outTo);
    }

    public boolean isWithHeader() {
        return withHeader;
    }

    public void setWithHeader(boolean withHeading) {
        this.withHeader = withHeading;
    }

    public boolean isAutoWidth() {
        return autoWidth;
    }

    public void setAutoWidth(boolean autoWidth) {
        this.autoWidth = autoWidth;
    }

    public String getHeadingsStyle() {
        return headingsStyle;
    }

    public void setHeadingsStyle(String headingsStyle) {
        this.headingsStyle = headingsStyle;
    }

    public int getFirstRow() {
        return firstRow;
    }

    public void setFirstRow(int startRow) {
        this.firstRow = startRow;
    }

    public int getFirstColumn() {
        return firstColumn;
    }

    public void setFirstColumn(int startColumn) {
        this.firstColumn = startColumn;
    }

    public boolean isAutoFilter() {
        return autoFilter;
    }

    public void setAutoFilter(boolean autoFilter) {
        this.autoFilter = autoFilter;
    }

    public int getLastRow() {
        return lastRow;
    }

    public String[] getHeadings() {
        return headings;
    }

    /**
     * Getter for sheet name.
     *
     * @return The sheet name.
     */
    public String getSheetName() {
        return sheetName;
    }

    /**
     * Setter for sheet name.
     *
     * @param sheetName The sheet name.
     */
    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }

    /**
     * Setter for mapped styles.
     *
     * @param styleName The name of the styles.
     * @param styleBean The style bean. If null then the style of the
     *                  given name will be removed.
     */
    public void setStyles(String styleName, StyleBean styleBean) {
        if (styleBean == null) {
            styles.removeStyle(styleName);
        } else {
            styles.registerStyle(styleName, styleBean);
        }
    }

    public DataSchema getSchema() {
        return schema;
    }

    public void setSchema(DataSchema schema) {
        this.schema = schema;
    }

    @Override
    public String toString() {
        String name = sheetName;
        return getClass().getSimpleName() +
                (name == null ? "" : " " + name);
    }
}
